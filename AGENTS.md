# ClearFlow Project Guidelines (AGENTS.md)

This document outlines the architectural principles, coding standards, and best practices for the ClearFlow backend project. All contributors (human and AI) should adhere to these guidelines to ensure consistency and maintainability.

## ðŸ—ï¸ Architectural Principles

### 1. Layered Architecture
Maintain strict separation between layers:
- **Handlers (`internal/api/handlers/`)**: Handle HTTP-specific logic (parsing, status codes, JSON responses). They should call Services, NOT direct Repositories or DB queries.
- **Services (`internal/services/`)**: Contain the **Business Logic**. This layer orchestrates data between repositories, performs calculations, and enforces business rules.
- **Repositories (`internal/repositories/`)**: Abstract data access. Use `Go-Jet` for all queries. Return domain models or slices of models.
- **Models (`db/model/`)**: Generated by `Go-Jet`. These represent the database schema. Avoid adding logic to these structs.

### 2. Dependency Injection
- Pass dependencies (services, repositories, validators, configs) into constructors.
- Prefer passing interfaces rather than concrete types to facilitate testing.
- Constructors should follow the naming convention `New[Type]Handler`, `New[Type]Service`, or `New[Type]Repository`.

### 3. Explicit Context
- Always pass `context.Context` from the handler down to the database layer.
- Use context for cancellation and timeouts.

## ðŸ’» Coding Standards

### 1. Idiomatic Go
- Follow [Effective Go](https://golang.org/doc/effective_go.html).
- Keep functions small and focused.
- Use meaningful names; avoid overly cryptic abbreviations.

### 2. Error Handling
- Never ignore errors (`_ = ...`).
- Wrap errors with context when moving up layers (e.g., `fmt.Errorf("failed to fetch user: %w", err)`).
- Use `u.WriteJSONError` in handlers to standardize error responses to the client.

### 3. Validation
- Use the central `validator.Validate` instance passed to handlers.
- Use struct tags (`validate:"required,min=1"`) for validation rules.
- Validate request bodies and query parameters early in the handler.

## ðŸ—„ï¸ Database Conventions

### 1. Migrations First
- Every schema change must start with a migration in `db/migrations/`.
- Use the `Makefile` commands (`make migrate-up`, `make migrate-down`) to manage state.

### 2. Type-Safe SQL with Go-Jet
- Always use `Go-Jet`'s generated table and model packages.
- Regenerate models after every migration using `make jet-generate`.
- Avoid raw SQL strings unless absolutely necessary for complex performance reasons.

## ðŸ”Œ API Design

### 1. RESTful Principles
- Use appropriate HTTP methods (GET, POST, PUT, DELETE).
- Return standard HTTP status codes.
- Version your API (currently `/api/v1`).

### 2. JSON Consistency
- Use the `internal/utils/json.go` helpers for writing responses.
- Ensure all request/response bodies use `camelCase` for JSON keys.

## ðŸ¤– AI Interaction Guidelines
- **BUILD SAFETY (CRITICAL)**: Always run `go mod tidy` and verify the build with `go build` after adding dependencies or changing imports. Never assume `go.sum` is updated automatically.
- When adding new functionality, follow the flow: Handler -> Service -> Repository.
- When adding new handlers, always update the `Handlers` struct in `internal/api/router.go` and wire them up in `main.go`.
- When modifying the database schema, provide the SQL migration and ensure `jet-generate` is run.
- Check existing patterns in `internal/repositories/user.go` or `internal/api/handlers/user.go` before implementing new features.
